#!/usr/bin/env bash
###############################################################################
# Script Name  : bu
# Description  : USB backup tool
# Dependencies : rsync
# Arguments    : --help, --backup --restore (runs backup by default)
# Author       : Copyright (C) 2023, Richard B. Romig, Created: 04 Feb 2023
# Email        : rick.romig@gmail.com | rick.romig@mymetronet.com
# Comments     : Based on USB Backup Tool (Version 1.1) by Joe Collins. (https://www.ezeelinux.com)
#              : Joe's code at: https://github.com/EzeeLinux/bu-usb_backup_tool
# Last updated : 28 Nov 2023
# TODO (Rick)  : 
# License      : GNU General Public License, version 2.0
###############################################################################

# BU -- USB Backup Tool (Version 1.1) -- by Joe Collins. (https://www.ezeelinux.com)
# Debian/Ubuntu Linux systems. (May 10, 2019)
# (GNU/General Public License version 2.0)
# For Debian 9 and up, Ubuntu 16.04 and up and Linux Mint 18.x and up.

## Shellcheck Directives ##
# shellcheck source=/home/rick/bin/functionlib
# shellcheck disable=SC1091,SC2034

# Load function library

if [[ -x "$HOME/bin/functionlib" ]]; then
  source "$HOME/bin/functionlib"
else
  printf "\e[91mERROR:\e[0m functionlib not found!\n" >&2
  exit 1
fi

## Global Variables ##

readonly _version="3.13"
readonly user=$USER
readonly host="${HOSTNAME:-$(hostname)}"
readonly mount_point="/media/$user/BU_Drive"

## Functions ##

drive_test() {
	printf "Checking Backup USB Drive...\n"
  check_usb || die "No USB drive connected!" 1
	bu_drive_label || die "Invalid partition label. Run 'bu --help' for drive setup information." 1 
  check_uuid || die "Incorrect drive to backup $host." 1
  mount | grep -qw BU_Drive > /dev/null 2>&1 || mount_bu
  bu_drive_fs || die "Drive must be formatted with EXT4 or XFS." 1
	printf "Space available on BU_Drive: %s\n" "$(df -h "$mount_point" | tail -n1 | awk '{print $4}')"
	printf "USB Backup Drive is mounted and meets all criteria.\n"
}

check_usb() {
	[[ $(lsblk -S -o  TRAN | grep 'usb') = *usb* ]] && return "$TRUE" || return "$FALSE"
}

bu_drive_label() {
	bu_label="$(lsblk -o label | grep -w BU_Drive)"
	[[ -n "$bu_label" ]] && return "$TRUE" || return "$FALSE"
}

check_uuid() {
  local uuid=( "5d3290de-3fa7-4e3c-94b8-aca062c427ef" "5d1a8caa-36cf-4a36-8457-1a2bb2f85fd3" "89740987-ca0a-4b33-bb56-9055bb9e1daa" )
  local hname=( "hp-800g2-sff" "hp-850-g3" "hp-probook-6570" )
	local uuid_path="/dev/disk/by-uuid"
	
	if [[ -L "$uuid_path/${uuid[0]}" ]]; then
		[[ "$host" == "${hname[0]}" ]] && return "$TRUE" || return "$FALSE"
	elif [[ -L "$uuid_path/${uuid[1]}" ]]; then
		[[ "$host" == "${hname[1]}" ]] && return "$TRUE" || return "$FALSE"
	elif [[ -L "$uuid_path/${uuid[2]}" ]]; then
		[[ "$host" == "${hname[2]}" ]] && return "$TRUE" || return "$FALSE"
  else
	  return "$TRUE"
	fi
}

mount_bu() {
  usbdrv="$(lsblk -fs | awk '/BU_Drive/ {print $1}')"
  [[ -d "$mount_point" ]] || sudo mkdir -p "$mount_point"
  sudo mount /dev/"$usbdrv" "$mount_point"
}

bu_drive_fs() {
	fs_type="$(mount | awk '/BU_Drive/ {print $5}')"
	[[ "$fs_type" == "ext4" || "$fs_type" == "XFS" ]] && return "$TRUE" || return "$FALSE"
}

sync_drives() {
	printf "Wait! Syncing Drives"
	dots "."
	sync
	kill "$!"
	printf "done\n"
  tput cnorm
}

unmount_usb_drive() {
  sudo umount "$mount_point" && printf "BU_Drive unmounted.\n"
  [[ -d "$mount_point" ]] && sudo rmdir "$mount_point"
  printf "It's now safe to remove the USB drive.\n"
}

script_time() {
  printf "Script completed in %s\n" "$(format_time $SECONDS)"
}

backup() {
  printf "Changing ownership of BU_Drive to %s...\n" "$user"
  sudo chown "$user" "$mount_point"

  printf "Checking for/creating machine specific directories...\n"
  [[ -d "$mount_point"/BU_Backups/"$host" ]] || mkdir -p "$mount_point"/BU_Backups/"$host"
	printf "BU_Drive is ready.\n"

  printf "Backing up /etc and /home to BU_Drive/BU_Backups/%s/...\n" "$host"
  if sudo rsync -aH --delete --exclude 'timeshift' --exclude '.local/share/libvirt/images' --exclude 'mnt' --info=progress2 /etc /home "$mount_point"/BU_Backups/"$host"/;   then
    # Clear any accidental input during backup:
    read -rt 1 -n 10000 discard
    box "Backup completed." "*"
    # Remove old and create new timestamp file:
    rm -f /"$mount_point"/BU_Backups/"$host"/BU\ Backup* >/dev/null 2>&1
    touch "$mount_point/BU_Backups/$host/BU Backup was successful: $(date '+%F')"
		sync_drives
    unmount_usb_drive
    script_time
    exit
  else
    # Clear any accidental input during backup:
    read -rt 1 -n 10000 discard
    # Remove old timestamp file and create a new one:
    rm -f "$mount_point"/BU_Backups/"$host"/BU\ Backup* >/dev/null 2>&1
    touch "$mount_point/BU_Backups/$host/BU Backup had some errors: $(date '+%F')"
    printf "There were errors! Try reinserting the backup drive and running the command again to correct them.\n" >&2
    printf "If errors persist then you may have corrupt files or failing hardware.\n" >&2
    unmount_usb_drive
    script_time
    exit 1
  fi
}

restore() {
  # Restore host's /home directory.

  if [[ ! -d "$mount_point"/BU_Backups/"$host"/ ]]; then
    printf "%s Cannot find valid backup directory for %s!\n" >&2 "$red_error" "$host"
    printf "- This drive may not have been used to backup this machine.\n" >&2
    printf "- BU_Backups/%s directory may have been moved or deleted.\n" >&2 "$host"
    printf "- Hostname or username may have changed since last backup.\n" >&2
    exit 1
  fi

  printf "\nBU Restore Function\n"
  printf "\n%s\n" "$red_warning"
  printf "Any new files created in /home since last backup WILL BE DELETED!\n"
  if y_or_n "Are you sure you want to restore now? [y/n]"; then
    printf "Close any running applications and press any key to continue.\n"
    read -rn 1 -s
    printf $"\nRestoring /home... Please DO NOT open any applications.\n"
    if sudo rsync -aH --delete --exclude 'timeshift' --info=progress2 "$mount_point"/BU_Backups/"$host"/home/ /home/; then
      # Clear any accidental input during restore:
      read -rt 1 -n 10000 discard
      box "Restoration Complete!" "*"
			sync_drives
      unmount_usb_drive
      printf "Restart machine for all changes to take effect.\n"
      script_time
      exit
    else
      # If rsync fails, clear any accidental input during restore:
      read -rt 1 -n 10000 discard
      printf "\n%s rsync exited with errors!\n" >&2 "$red_error"
      printf "DO NOT DO ANYTHING UNTIL YOU:\n" >&2
      printf "\nMake sure BU_Drive USB is still plugged in.\n" >&2
      printf "Remount BU_Drive USB by unplugging it and plugging it back in.\n" >&2
      printf "Wait a few seconds and try running 'bu --restore' again.\n" >&2
      printf "You may need to manually restore your data if errors persist.\n" >&2
      mount | grep -qw BU_Drive > /dev/null 2>&1 && unmount_usb_drive
      script_time
      exit 1
    fi
  else
    printf "Restoration canceled.\n"
    unmount_usb_drive
    script_time
    exit
  fi
}

help() {
less << END_HELP

 BU - USB Backup Tool (Version $_version) -- Help

 Press "q" to exit this Help page.

 Commands:

 bu = Fully backs up host's /etc and /home directories to BU_Drive.
 bu --backup = Fully backs up host's /etc and /home directories.
 bu --help = Prints this help information.
 bu --restore = Accesses BU Restore function.

 Description:

 BU is a program that makes keeping all of your user data safely backed up on
 a dedicated External USB drive easy.

 BU will update files that have changed, remove files that have been
 deleted and add any new files that have been created since the last backup.
 The initial backup can take a lot of time if you have a lot of data stored
 in your system's /home directory. BU creates a directory with the host name
 of the machine it's backing up from inside BU_Backups. This allows users to
 share one BU_Drive with multiple machines.

 The directory structure and all files are stored openly to allow users easy
 access if they only need to retrieve a few files or directories using a file
 manager.

 The BU Restore function is an interactive tool that let's users restore their
 /home directories to a backup up state. This function will only work when
 restoring to a machine with the exact same hostname as the one the backs were
 made from. It is intended for emergency use, as when significant number of
 directories and files are accidentally removed from /home.

 BU_Drive Setup

 You need to prepare a BU Drive with a tool like Gparted or Disks.
 This can be any USB storage device. The dedicated USB drive MUST contain a
 partition formatted with a Linux native file system such as Ext4 or XFS. The
 partition MUST be labeled "BU_Drive" so BU can find it and use it for backups.
 The partition needs to have enough free capacity to store all data in /home on
 all of the machines you want to use the drive for. Note: You will get many
 errors if you attempt to use BU to backup to a partition that is formatted with
 non-native file systems like FAT32 or NTFS.

 Disclaimer:

 THIS SOFTWARE IS PROVIDED BY EZEELINUX “AS IS” AND ANY EXPRESS OR IMPLIED
 WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
 EVENT SHALL EZEELINUX BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
 IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 POSSIBILITY OF SUCH DAMAGE.

END_HELP
}

## Execution ##

# Start timer
SECONDS=0
box "BU -- USB Backup Tool (Version $_version)"
printf "Copyright \UA9 2019, Joe Collins\nCopyright \UA9 2023, Rick Romig\n"

# Check command line arguments:
if [[ "$#" -eq 0 ]]; then
  user_in_sudo
  sleep 2
  printf '\e[A\e[K'
	drive_test
	check_package rsync
	backup
else
  case "$1" in
    "--backup" )
      user_in_sudo
      sleep 2
      printf '\e[A\e[K'
	    drive_test
	    check_package rsync
	    backup
    ;;
    "--help" )
      help
      exit
    ;;
    "--restore" )
      user_in_sudo
      sleep 2
      printf '\e[A\e[K'
	    drive_test
	    check_package rsync
	    restore
    ;;
    * )
      printf "%s %s is not a valid option.\n" "$red_error" "$1" >&2
      printf "Valid options:\n" >&2
      printf "\tbu --%s\n" "backup" "help" "restore" >&2
      printf "\tbu without an argument performs a backup of /etc/ and /home directories.\n" >&2
      exit 1
  esac
fi
