#!/usr/bin/env bash
###############################################################################
# Script Name  : bu
# Description  : Backup /etc and /home directories to an external USB drive
# Dependencies : rsync
# Arguments    : see help() function for usage and options
# Author       : Copyright (C) 2023, Richard B. Romig
# Email        : rick.romig@gmail.com | rick.romig@mymetronet.com
# Created      : 04 Feb 2023
# Last updated : 22 Feb 2026
# Comments     : Based on BU USB Backup Tool (Version 1.1) by Joe Collins.
# TODO (Rick)  :
# License      : GNU General Public License, version 2.0
# License URL  : https://github.com/RickRomig/scripts/blob/main/LICENSE
##########################################################################
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
##############################################################################

## Shellcheck Directives ##
# shellcheck source=/home/rick/bin/functionlib

# Load function library

if [[ -x "$HOME/bin/functionlib" ]]; then
  source "$HOME/bin/functionlib"
else
  printf "\e[91mERROR:\e[0m functionlib not found!\n" >&2
  exit 1
fi

## Global Variables ##

readonly script="${0##*/}"
readonly version="6.5.26053"
user=$(whoami); readonly user
readonly host="${HOSTNAME:-$(hostname)}"
readonly mount_point="/media/$user/BU_Drive"
readonly logfile="$HOME/.local/share/logs/BU.log"
exit_status=0
SECONDS=0
DOTS_PID=

## Functions ##

drive_test() {
	printf "%sChecking Backup USB Drive%s\n" "$green" "$normal"
	check_usb || dielog "No USB drive connected!" "$logfile" "$E_DRIVE_ERROR"
	bu_drive_label || dielog "Invalid partition label. Run 'bu -i' for drive setup information." "$logfile" "$E_DRIVE_ERROR"
  check_uuid || { unmount_usb_drive; dielog "Incorrect backup drive." "$logfile" "$E_DRIVE_ERROR"; }
  is_deb13 && mount_bu
  bu_drive_fs || dielog "Drive must be formatted with EXT4 or XFS." "$logfile" "$E_DRIVE_ERROR"
	get_space_remaining
	printf "USB Backup Drive is mounted and meets all criteria.\n"
}

check_usb() {
	[[ $(grep 'usb' <(lsblk -S -o TRAN)) = *usb* ]] && return "$TRUE" || return "$FALSE"
}

bu_drive_label() {
	local bu_label
	bu_label="$(grep -w BU_Drive <(lsblk -o label))"
	[[ "$bu_label" ]] && return "$TRUE" || return "$FALSE"
}

check_uuid() {
	local uuid_path="/dev/disk/by-uuid"
	declare -rA uuid_list=(
		[hp-800g2-sff]="5d3290de-3fa7-4e3c-94b8-aca062c427ef"
		[hp-850-g3]="5d1a8caa-36cf-4a36-8457-1a2bb2f85fd3"
		[hp-probook-6570]="89740987-ca0a-4b33-bb56-9055bb9e1daa"
		[lenovo-m91p]="772dcef3-6f46-4e58-b6d1-00ca9292c062"
		[hp-6005]="aecf4050-4efd-43e8-bd4c-cef2edd34b11"
		[e6500-deb]="aecf4050-4efd-43e8-bd4c-cef2edd34b11"
		[probook-6570b]="aecf4050-4efd-43e8-bd4c-cef2edd34b11"
		[hp-8300]="aecf4050-4efd-43e8-bd4c-cef2edd34b11"
		[hp-8300-usdt]="aecf4050-4efd-43e8-bd4c-cef2edd34b11"
		[hp-800-g1-usdt]="aecf4050-4efd-43e8-bd4c-cef2edd34b11"
		[hp-800-g1-dm]="aecf4050-4efd-43e8-bd4c-cef2edd34b11"
		[probook-6570]="aecf4050-4efd-43e8-bd4c-cef2edd34b11"
		[hp-2560p]="aecf4050-4efd-43e8-bd4c-cef2edd34b11"
		[e-475m]="aecf4050-4efd-43e8-bd4c-cef2edd34b11"
	)
	[[ -L "$uuid_path/${uuid_list[$host]}" ]] && return "$TRUE" || return "$FALSE"
	# case "$host" in
	# 	hp-800g2-sff | hp-850-g3 | hp-probook-6570 | lenovo-m91p )
	# 		[[ -L "$uuid_path/${uuid_list[$host]}" ]] && return "$TRUE" || return "$FALSE" ;;
	# 	* )
	# 		return "$TRUE"
	# esac
}

is_deb13() {
	local deb13
	if is_debian; then
		deb13=$(cut -d'.' -f1 </etc/debian_version)
		(( deb13 >= 13 )) 2>/dev/null && return "$TRUE" || return "$FALSE"
	fi
	return "$FALSE"
}

mount_bu() {
  local usbdrv
  usbdrv="$(awk '/BU_Drive/ {print $1}' <(lsblk -fs))"
  [[ -d "$mount_point" ]] || sudo mkdir -p "$mount_point"
  sudo mount /dev/"$usbdrv" "$mount_point"
}

unmount_usb_drive() {
	printf "Unmounting %s...\n" "$mount_point"
	if is_deb13; then
		sudo umount "$mount_point"
	else
		umount "$mount_point"
	fi
	if grep -q 'BU_Drive' <(mount); then
		log "$RED_ERROR $mount_point failed to unmount. ($E_DRIVE_ERROR)" "$logfile"
		exit_status="$E_DRIVE_ERROR"
	else
		printf "BU_Drive unmounted.\nIt is now safe to remove the USB drive.\n"
	fi
}

bu_drive_fs() {
  local fs_type
	fs_type="$(awk '/BU_Drive/ {print $2}' <(lsblk -f))"
	[[ "$fs_type" == "ext4" || "$fs_type" == "XFS" ]] && return "$TRUE" || return "$FALSE"
}

flush_kb_buffer() {
	while read -r -N 1 -t 0.01
	do :
	done
}

sync_drives() {
	printf "Syncing Drives..."
	dots "." &
	DOTS_PID="$!"
	sync
	kill_dots
}

get_space_remaining() {
	local avail
	avail="$(awk 'NR == 2 {print $4}' <(df -h "$mount_point"))"
	printf "Space available on BU_Drive: %s\n" "$avail"
}

trim_log() {
	local loglen
	loglen=$(wc -l < "$logfile")
	[[ "$loglen" -le 30 ]] && return
	while [[ "$loglen" -gt 30 ]]; do
		sed -i '2d' "$logfile"
		(( loglen-- ))
	done
}

bu_prep() {
  printf "Changing ownership of BU_Drive to %s...\n" "$user"
	sudo chown "$user" "$mount_point"
	printf "Checking for/creating machine specific directories...\n"
	[[ -d "$mount_point"/BU_Backups/"$host" ]] || mkdir -p "$mount_point"/BU_Backups/"$host"
	printf "BU_Drive is ready.\n"
}

backup() {
	local item
	local excluded=('timeshift' 'lost+found' 'mnt' '.local/share/libvirt/' '.local/share/gnome-boxes/' '.cache/' '.local/share/Trash/' 'Downloads/ISO/')
	local exclude_opts=()
	for item in "${excluded[@]}"; do exclude_opts+=( --exclude="$item" ); done
  printf "%sBacking up /etc and /home to BU_Drive/BU_Backups/%s/%s\n" "$green" "$host" "$normal"
  if sudo rsync -aH --delete "${exclude_opts[@]}" --info=progress2 /etc /home "$mount_point"/BU_Backups/"$host"/ 2>>"$logfile"; then
    # Clear any accidental input during backup:
		flush_kb_buffer
		printf "%sBackup successfully completed.%s\n" "$green" "$normal"
    rm -f /"$mount_point"/BU_Backups/"$host"/BU\ Backup* >/dev/null 2>&1
    touch "$mount_point/BU_Backups/$host/BU Backup was successful: $(date '+%F')"
		get_space_remaining
	else
    # Clear any accidental input during backup:
		flush_kb_buffer
    rm -f "$mount_point"/BU_Backups/"$host"/BU\ Backup* >/dev/null 2>&1
    touch "$mount_point/BU_Backups/$host/BU Backup had some errors: $(date '+%F')"
		log "$RED_ERROR rsync exited with errors!" "$logfile"
		printf "* Try reinserting the backup drive and running the command again to correct them.\n" >&2
    printf "* If errors persist then you may have corrupt files or failing hardware.\n" >&2
		exit_status=90
  fi
}

restore() {
  # Restore host's /home directory.
  if [[ -d "$mount_point"/BU_Backups/"$host"/ ]]; then
	  printf "%s\n" "$RED_WARNING"
		printf "Any new files created in /home since last backup WILL BE DELETED!\n"
		if y_or_n "Are you sure you want to restore now? [y/n]"; then
			printf "Close any running applications and press any key to continue.\n"
			anykey
			printf "\n%sRestoring /home... Please DO NOT open any applications.$s\n" "$green" "$normal"
			if sudo rsync -aH --delete --exclude 'timeshift' --info=progress2 "$mount_point"/BU_Backups/"$host"/home/ /home/ 2>>"$logfile"; then
				# Clear any accidental input during restore:
				flush_kb_buffer
				printf "%sRestoration successfully complete!%s\n" "$green" "$normal"
	      printf "Restart machine for all changes to take effect.\n"
				else
				# If rsync fails, clear any accidental input during restore:
				flush_kb_buffer
				log "$RED_ERROR rsync exited with errors!" "$logfile"
				printf "DO NOT DO ANYTHING UNTIL YOU:\n" >&2
				printf "* Make sure BU_Drive USB is still plugged in.\n" >&2
				printf "* Remount BU_Drive USB by unplugging it and plugging it back in.\n" >&2
				printf "* Wait a few seconds and try running 'bu --restore' again.\n" >&2
				printf "* You may need to manually restore your data if errors persist.\n" >&2
	      exit_status=91
			fi
		else
			log "${orange}Restoration canceled.${normal}" "$logfile"
	  fi
	else
		log "$RED_ERROR Cannot find valid backup directory for $host!" "$logfile"
    printf "* This drive may not have been used to backup this machine.\n" >&2
    printf "* BU_Backups/%s directory may have been moved or deleted.\n" "$host" >&2
    printf "* Hostname or username may have changed since last backup.\n" >&2
    exit_status="$E_FILENOTFOUND"
	fi
}

help() {
	local errcode="${1:-1}"
	local updated="22 Feb 2026"
	cat << _HELP_
${orange}$script${normal} $version, Updated: $updated
Backup /etc/ and /home/ directories to an external USB drive.

${green}Usage:${normal} $script [-bhirs]
${orange}Available options:${normal}
  -b  Backup the host /etc and /home directories.
  -h  Show this help message and exit.
  -i  Instructions for setting up the BU_Drive.
  -r  Restore the host /home directory.
${orange}Notes:${normal}
  - A dedicated USB storage device with sufficient capacity for each host.
  - The backup drive must be formatted with ext4 or XFS.
  - The backup partition must be labeled 'BU_Drive'
  - The decicated backup drive can be only used on a single system.
_HELP_
  exit "$errcode"
}

drive_setup() {
	cat << _SETUP_
 ${orange}BU_Drive Setup:${normal}
 - Prepare the backup drive with a tool like Gparted or Gnome Disks.
 - This can be any USB storage device. Recommend an external hard drive or SSD.
 - The USB drive MUST contain a partition formatted with a Linux native file
   system such as Ext4 or XFS.
 - The partition MUST be labeled "BU_Drive" so BU can find it and use it for backups.
 ${orange}Notes:${normal}
 - The partition needs to have enough free capacity to store all data in /home on
   all of the machines you want to use the drive for.
  - A backup drive needs to be dedicated to  machine by adding the machine's
    hostname and the drive's UUID to the check_uuid function.

_SETUP_
	over_line "$script $version"
	exit
}

log_status() {
	case "$exit_status" in
		0 ) log "Backup/Restore operation successful." "$logfile" ;;
		81 ) log "Unable to find backup directory for restore." "$logfile" ;;
		85 ) log "Failed to unmount BU_Drive." "$logfile" ;;
		90 ) log "Backup operation had errors." "$logfile" ;;
		91 ) log "Restore operation had errors." "$logfile" ;;
		* ) log "Unknown error." "$logfile" ;;
	esac
}

main() {
	local noOpt optstr opt OPTARG OPTIND loglen
	[[ -f "$logfile" ]] || echo "${logfile##*/}" > "$logfile"
	clear
	box "${script^^} -- USB Backup Tool (Version $version)"
	noOpt=1
	optstr=":bhir"
	while getopts "$optstr" opt; do
		case "$opt" in
			b )
				sudo_login 2
				drive_test
				check_package rsync
				bu_prep
				backup
				sync_drives
				unmount_usb_drive
				;;
			h )
				help 0
				;;
			i )
				drive_setup
				;;
			r )
				sudo_login 2
				drive_test
				check_package rsync
				restore
				sync_drives
				unmount_usb_drive
				;;
			? )
				printf "%s Invalid option -%s\n" "$RED_ERROR" "$OPTARG" >&2
				help 2
		esac
		noOpt=0
	done
	[[ "$noOpt" -eq 1 ]] && { printf "%s No argument passed.\n" "$RED_ERROR" >&2; help "$E_MISSING_ARG"; }
	shift "$(( OPTIND - 1 ))"
	log_status
	trim_log
	over_line "Backup completed in $(format_time $SECONDS)" "-"
	exit "$exit_status"
}

## Execution ##

main "$@"
