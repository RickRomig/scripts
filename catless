#!/usr/bin/env bash
#############################################################################
# Script Name  : catless
# Description  : view text file with less or cat based on terminal window size.
# Dependencies : none
# Arguments    : See help()
# Author       : Copyright Â©  2020, Richard B. Romig, LudditeGeek@Mosfanet
# Email        : rick.romig@gmail.com | rick.romig@mymetronet.com
# Crated       : 02 Jan 2020
# Updated      : 28 Feb 2026
# Comments     : Checks to see if passed argument is a valid text or json file.
# TODO (Rick)  :
# License      : GNU General Public License, version 2.0
# License URL  : https://github.com/RickRomig/scripts/blob/main/LICENSE
#############################################################################
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#############################################################################

## Shellcheck Directives ##
# shellcheck source=/home/rick/bin/functionlib

## Load function library ##

if [[ -x "$HOME/bin/functionlib" ]]; then
  source "$HOME/bin/functionlib"
else
  printf "\e[91mERROR:\e[0m functionlib not found!\n" >&2
  exit 81
fi

## Global Variables ##

readonly script="${0##*/}"
readonly version="6.7.26059"
EC=0

## Functions ##

help() {
  local errcode="${1:-1}"
  local updated="28 Feb 2026"
  cat << _HELP_
${orange}$script${normal} $version (updated $updated)
Displays a text file using either cat or less depending the number of lines in
the file and the number of rows in the current terminal window. Less is used when
the number of lines is greater than the 87% of the rows, otherwise cat is used.

${green}Usage:${normal} $script [-h] [-f filename] [-n filename]
${orange}Available options:${normal}
  -f  View file without line numbers.
  -h  Show this help message and exit.
  -n  View file with line numbers.
_HELP_
  exit "$errcode"
}

check_file() {
	local filename="$1"
	if [[ ! -f "$filename" ]]; then
		printf "%s %s not found.\n" "$RED_ERROR" "$filename" >&2
		EC="$E_FILENOTFOUND"
		return "$FALSE"
	elif [[ ! -s "$filename" ]]; then
		printf "%s %s is an empty file.\n" "$RED_ERROR" "$filename" >&2
		EC="$E_INVALID_ARG"
		return "$FALSE"
	elif grep -qEi "text|json" <(file -bL "$filename"); then
		return "$TRUE"
	else
		printf "%s %s is not a text file.\n" "$RED_ERROR" "$filename" >&2
		EC="$E_INVALID_ARG"
		return "$FALSE"
	fi
}

over_max() {
	# Returns TRUE (0) if number of lines deems use of less
	local catmax filelines textfile
	textfile="$1"
	catmax=$(( $(tput lines)*87/100 ))
	filelines=$(wc -l < "$textfile")
	(( filelines > catmax )) && return "$TRUE" || return "$FALSE"
}

view_file() {
  local textfile="$1"
  local linenumbers="$2"
  if over_max "$textfile"; then
    case "$linenumbers" in
      0 )
        less -N "$textfile" ;;
      * )
        less "$textfile"
    esac
    head -n5 "$textfile"
  else
    case "$linenumbers" in
      0 )
        cat -n "$textfile" ;;
      * )
        cat "$textfile"
    esac
  fi
  printf "%sFile: %s%s\n" "$reverse" "$textfile" "$normal"
}

main() {
	local noOpt opt optstr filename linenumbers OPTARG OPTIND
	linenumbers="$FALSE"
	noOpt=1
	optstr=":f:hn:"
	while getopts "$optstr" opt; do
		case "$opt" in
			f )
				filename="$OPTARG"
				check_file "$filename" && view_file "$filename" "$linenumbers"
				;;
			h )
				help 0
				;;
			n )
				filename="$OPTARG"
				linenumbers="$TRUE"
				check_file "$filename" && view_file "$filename" "$linenumbers"
				;;
			: )
				printf "%s Must supply an argument to -%s.\n" "$RED_ERROR" "$OPTARG" >&2
				help "$E_MISSING_ARG"
				;;
			? )
				printf "%s Invalid option -%s\n" "$RED_ERROR" "$OPTARG" >&2
				help "$E_INVALID_ARG"
		esac
		noOpt=0
	done
	[[ "$noOpt" = 1 ]] && { printf "%s No option passed.\n" "$RED_ERROR" >&2; help "$E_MISSING_ARG"; }
	shift "$(( OPTIND - 1 ))"
	over_line "$script $version"
	exit "$EC"
}

## Execution ##

main "$@"
